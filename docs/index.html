<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>REAP: REAP</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">REAP<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Facilitates parsing of procfs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">REAP </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_README"></a> *"We will encourage you to develop the three great virtues of a programmer: laziness, impatience, and hubris.‚Äù* - Larry Wall

The REAP library provides Ridiculously Easy Access to Procfs.

@section autotoc_md0 API


You can access all of REAP's functionality by

@code{c} 
#include &lt;reap/reap.h&gt;
@endcode

@subsection autotoc_md1 Process info


You can get basic information about a running process through the &lt;tt&gt;reapGetProcInfo&lt;/tt&gt; function.  Its signature is

@code{c} 
int reapGetProcInfo(pid_t pid, reapProcInfo *info, char *exe_path, size_t path_size);
@endcode

where &lt;tt&gt;reapProcInfo&lt;/tt&gt; is defined as

@code{c} 
typedef struct reapProcInfo {
    pid_t pid;  // Process ID.
    pid_t ppid; // Parent process ID.
    pid_t tid;  // Task ID.
    uid_t uid;  // User ID.
    uid_t euid; // Effective user ID.
    gid_t gid;  // Group ID.
    gid_t egid; // Effective group ID.
} reapProcInfo;
@endcode

&lt;tt&gt;reapGetProcInfo&lt;/tt&gt; returns &lt;tt&gt;REAP_RET_OK&lt;/tt&gt; if successful and an error code otherwise (defined in &lt;a href="<a class="el" href="definitions_8h.html" title="Provides library-wide definitions.">include/reap/definitions.h</a>" &gt;reap/definitions.h&lt;/a&gt;).  In addition to the error codes defined in that file, various REAP functions can return negative values.  Such values will be equal to &lt;tt&gt;-1 * errno&lt;/tt&gt;.

You can also pass a task ID (i.e., a value returned by the &lt;tt&gt;gettid&lt;/tt&gt; system call) as &lt;tt&gt;pid&lt;/tt&gt;.

If &lt;tt&gt;exe_path&lt;/tt&gt; is not &lt;tt&gt;NULL&lt;/tt&gt; and is of size &lt;tt&gt;path_size&lt;/tt&gt;, then it will be populated with the path to the process' executable.

@subsection autotoc_md2 Error messages


When an error occurs, you can get a description of the error by

@code{c} 
char *reapGetError(void);
@endcode

The referenced buffer (which is unique to each thread) will be of size &lt;tt&gt;REAP_ERROR_BUFFER_SIZE&lt;/tt&gt; (defined in &lt;a href="<a class="el" href="config_8h.html">include/reap/config.h</a>" &gt;reap/config.h&lt;/a&gt;).

@subsection autotoc_md3 Process iteration


A &lt;tt&gt;reapProcIterator&lt;/tt&gt; can be used to iterate over all of the running processes (at least, those for which the user has permission to access).

First, the iterator has to be created:

@code{c} 
int ret;
reapProcIterator *iterator;

ret = reapProcIteratorCreate(&amp;iterator);
if ( ret != REAP_RET_OK ) {
    // handle the error
}
@endcode

After that, we can repeatedly pull results from the iterator with

@code{c} 
int reapProcIteratorNext(const reapProcIterator *iterator, reapProcInfo *info, char *exe_path, size_t path_size);
@endcode

where the last three arguments are the same as for &lt;tt&gt;reapGetProcInfo&lt;/tt&gt;.

This function returns &lt;tt&gt;REAP_RET_OK&lt;/tt&gt; when yielding a result, &lt;tt&gt;REAP_RET_DONE&lt;/tt&gt; when the iterator has been exhausted, and an error code otherwise.

The iterator must be destroyed when it is no longer needed:

@code{c} 
reapProcIteratorDestroy(iterator);
@endcode

@subsection autotoc_md4 File descriptor iteration


A &lt;tt&gt;reapFdIterator&lt;/tt&gt; can be used to iterate over a process' open file descriptors.

First, the iterator has to be created:

@code{c} 
int ret;
reapFdIterator *iterator;

ret = reapFdIteratorCreate(some_pid, &amp;iterator);
if ( ret != REAP_RET_OK ) {
    // handle the error
}
@endcode

After that, we can repeatedly acquire file descriptor information with

@code{c} 
int reapFdIteratorNext(const reapFdIterator *iterator, reapFdResult *result, char *file, size_t file_size);
@endcode

where &lt;tt&gt;reapFdResult&lt;/tt&gt; is defined as

@code{c} 
typedef struct reapFdResult {
    int fd;
    dev_t device;
    ino_t inode;
    mode_t mode;
} reapFdResult;
@endcode

This function returns &lt;tt&gt;REAP_RET_OK&lt;/tt&gt; when yielding a result, &lt;tt&gt;REAP_RET_DONE&lt;/tt&gt; when the iterator has been exhausted, and an error code otherwise.

if &lt;tt&gt;file&lt;/tt&gt; is not &lt;tt&gt;NULL&lt;/tt&gt; and is of size &lt;tt&gt;file_size&lt;/tt&gt;, then it will be populated with the name of the underlying file. 

The iterator must be destroyed when it is no longer needed:

@code{c} 
reapFdIteratorDestroy(iterator);
@endcode

@subsection autotoc_md5 Memory map iteration


A &lt;tt&gt;reapMapIterator&lt;/tt&gt; can be used to iterate over a process' mapped memory segments.

First, the iterator has to be created:

@code{c} 
int ret;
reapMapIterator *iterator;

ret = reapMapIteratorCreate(some_pid, &amp;iterator);
if ( ret != REAP_RET_OK ) {
    // handle the error
}
@endcode

After that, we can repeatedly acquire mapped memory information with

@code{c} 
int reapMapIteratorNext(const reapMapIterator *iterator, reapMapResult *result, char *name, size_t name_size);
@endcode

where &lt;tt&gt;reapMapResult&lt;/tt&gt; is defined as

@code{c} 
typedef struct reapMapResult {
    unsigned long long start; // The start address of the memory segment.
    unsigned long long end; // The end address of the memory segment.
    unsigned long long offset; // The offset of the memory segment within the referent file (if any).
    int permissions; // The permissions of the memory segment.
    dev_t device; // The device number of the referent file (if any).
    ino_t inode; // The inode number of the referent file (if any).
} reapMapResult;
@endcode

The permissions are some bitwise-OR combination of &lt;tt&gt;PROT_READ&lt;/tt&gt;, &lt;tt&gt;PROT_WRITE&lt;/tt&gt;, and &lt;tt&gt;PROT_EXEC&lt;/tt&gt; from sys/mman.h.

This function returns &lt;tt&gt;REAP_RET_OK&lt;/tt&gt; when yielding a result, &lt;tt&gt;REAP_RET_DONE&lt;/tt&gt; when the iterator has been exhausted, and an error code otherwise.

If &lt;tt&gt;name&lt;/tt&gt; is not &lt;tt&gt;NULL&lt;/tt&gt; and is of size &lt;tt&gt;name_size&lt;/tt&gt;, then it will be populated with the name of the memory segment.

The iterator must be destroyed when it is no longer needed:

@code{c} 
reapMapIteratorDestroy(iterator);
@endcode

@subsection autotoc_md6 Thread iteration


A &lt;tt&gt;reapThreadIterator&lt;/tt&gt; can be used to iterate over a process' threads.

First, the iterator has to be created:

@code{c} 
int ret;
reapThreadIterator *iterator;

ret = reapThreadIteratorCreate(some_pid, &amp;iterator);
if ( ret != REAP_RET_OK ) {
    // handle the error
}
@endcode

After initialization, we can repeatedly acquire thread IDs with

@code{c} 
int reapThreadIteratorNext(const reapThreadIterator *iterator, pid_t *thread);
@endcode

This function returns &lt;tt&gt;REAP_RET_OK&lt;/tt&gt; when yielding a result, &lt;tt&gt;REAP_RET_DONE&lt;/tt&gt; when the iterator has been exhausted, and an error code otherwise.

The iterator must be destroyed when it is no longer needed:

@code{c} 
reapThreadIteratorDestroy(iterator);
@endcode

@subsection autotoc_md7 Socket iteration


A &lt;tt&gt;reapNetIterator&lt;/tt&gt; can be used to iterate over the open sockets in the network namespace.

First, the iterator has to be created:

@code{c} 
int ret;
reapNetIterator *iterator;

ret = reapNetIteratorCreate(0, &amp;iterator);
if ( ret != REAP_RET_OK ) {
    // handle the error
}
@endcode

The first parameter to the function holds zero or more flags combined with bitwise-OR.  The available flags are

* &lt;tt&gt;REAP_NET_FLAG_UDP&lt;/tt&gt;: Find UDP sockets.
* &lt;tt&gt;REAP_NET_FLAG_IPV6&lt;/tt&gt;: Find IPv6 sockets.
* &lt;tt&gt;REAP_NET_FLAG_DOMAIN&lt;/tt&gt;: Find Unix domain sockets.  If this flag is specified, then all other flags are ignored.

By default, the iterator will find TCP sockets over IPv4.

After initialization, we can repeatedly acquire socket information with

@code{c} 
int reapNetIteratorNext(const reapNetIterator *iterator, reapNetResult *result);
@endcode

where &lt;tt&gt;reapNetResult&lt;/tt&gt; is defined as

@code{c} 
typedef struct reapNetResult {
    union {
        struct { // For IP sockets.
            reapNetPeer local;
            reapNetPeer remote;
        };
        struct { // For Unix domain sockets.
            char path[108]; // Actually, the size is the same as that of the sun_path field of struct sockaddr_un.
            int socket_type; // E.g., SOCK_STREAM, SOCK_DGRAM, SOCK_SEQPACKET.
            unsigned int connected : 1;
        };
    };
    ino_t inode; // The inode number of the socket.
    unsigned int flags; // The flags that were passed to reapNetIteratorCreate.
} reapNetResult;
@endcode

where &lt;tt&gt;reapNetPeer&lt;/tt&gt; is defined as

@code{c} 
typedef struct reapNetPeer {
    uint16_t port;
    uint8_t address[16];
} reapNetPeer;
@endcode

If representing a Unix domain socket which is connected to an abstract socket address (i.e., where the first character of the path is a null byte), then all of the null bytes in the path will be replaced by &amp;lsquo;&amp;rsquo;@'`s.

This function returns &lt;tt&gt;REAP_RET_OK&lt;/tt&gt; when yielding a result, &lt;tt&gt;REAP_RET_DONE&lt;/tt&gt; when the iterator has been exhausted, and an error code otherwise.

The iterator must be destroyed when it is no longer needed:

@code{c} 
reapNetIteratorDestroy(iterator);
@endcode

@section autotoc_md8 Building REAP


Shared and static libraries are built using make.  Adding &lt;tt&gt;debug=yes&lt;/tt&gt; to the make invocation will disable optimization and build the libraries with debugging symbols.

You can also include REAP in a larger project by including make.mk.  Before doing so, however, the &lt;tt&gt;REAP_DIR&lt;/tt&gt; variable must be set to the location of the REAP directory.  You can also tell make where to place the shared and static libraries by defining the &lt;tt&gt;REAP_LIB_DIR&lt;/tt&gt; variable (defaults to &lt;tt&gt;$(REAP_DIR)&lt;/tt&gt;). Similarly, you can define the &lt;tt&gt;REAP_OBJ_DIR&lt;/tt&gt; variable which tells make where to place the object files (defaults to &lt;tt&gt;$(REAP_DIR)/src&lt;/tt&gt;).

make.mk adds a target to the &lt;tt&gt;CLEAN_TARGETS&lt;/tt&gt; variable.  This is so that implementing

@code{make} 
clean: $(CLEAN_TARGETS)
    ...
@endcode

in your project's Makefile will cause REAP to be cleaned up as well.

The &lt;tt&gt;CLEAN_TARGETS&lt;/tt&gt; variable should be added to &lt;tt&gt;.PHONY&lt;/tt&gt; if you're using GNU make.

make.mk defines the variables &lt;tt&gt;REAP_SHARED_LIBRARY&lt;/tt&gt; and &lt;tt&gt;REAP_STATIC_LIBRARY&lt;/tt&gt; which contain the paths of the specified libraries.

@section autotoc_md9 Testing


Testing can be performed through the &lt;a href="<a href="https://github.com/nickeldan/scrutiny">https://github.com/nickeldan/scrutiny</a>" &gt;Scrutiny framework. After installing at least version 0.5.0 of the framework, you can run REAP's tests by</p>
<div class="fragment"><div class="line">make tests</div>
</div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
