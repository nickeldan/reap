<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>REAP: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">REAP
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Facilitates parsing of procfs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">REAP Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> *"We will encourage you to develop the three great virtues of a programmer: laziness, impatience, and hubris.‚Äù* - Larry Wall</p>
<p>The REAP library provides Ridiculously Easy Access to Procfs.</p>
<h1><a class="anchor" id="autotoc_md0"></a>
API</h1>
<p>You can access all of REAP's functionality by</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;reap/reap.h&gt;</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1"></a>
Process info</h2>
<p>You can get basic information about a running process through the <code>reapGetProcInfo</code> function. Its signature is</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="proc_8h.html#a6dd4b635df0ee05a4202a473fbcddcae">reapGetProcInfo</a>(pid_t pid, <a class="code" href="structreapProcInfo.html">reapProcInfo</a> *info, <span class="keywordtype">char</span> *exe_path, <span class="keywordtype">size_t</span> path_size);</div>
<div class="ttc" id="aproc_8h_html_a6dd4b635df0ee05a4202a473fbcddcae"><div class="ttname"><a href="proc_8h.html#a6dd4b635df0ee05a4202a473fbcddcae">reapGetProcInfo</a></div><div class="ttdeci">int reapGetProcInfo(pid_t pid, reapProcInfo *info, char *exe_path, size_t path_size)</div><div class="ttdoc">Gets information about a running process/thread.</div></div>
<div class="ttc" id="astructreapProcInfo_html"><div class="ttname"><a href="structreapProcInfo.html">reapProcInfo</a></div><div class="ttdoc">Information concerning a running process/thread.</div><div class="ttdef"><b>Definition:</b> proc.h:22</div></div>
</div><!-- fragment --><p>where <code><a class="el" href="structreapProcInfo.html" title="Information concerning a running process/thread.">reapProcInfo</a></code> is defined as</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structreapProcInfo.html">reapProcInfo</a> {</div>
<div class="line">    pid_t <a class="code" href="structreapProcInfo.html#a905dda89a6a9c10b35d98b983b60a40c">pid</a>;  <span class="comment">// Process ID.</span></div>
<div class="line">    pid_t <a class="code" href="structreapProcInfo.html#a645f02562bdb93a66aa0b3143bc4c7d6">ppid</a>; <span class="comment">// Parent process ID.</span></div>
<div class="line">    pid_t <a class="code" href="structreapProcInfo.html#a2e89f5fc693e6427576206f2358d6508">tid</a>;  <span class="comment">// Task ID.</span></div>
<div class="line">    uid_t <a class="code" href="structreapProcInfo.html#adf2ed5c7d151224decad56d7c7bc9f54">uid</a>;  <span class="comment">// User ID.</span></div>
<div class="line">    uid_t <a class="code" href="structreapProcInfo.html#af37c3d463a772a7415930cb64e9b462e">euid</a>; <span class="comment">// Effective user ID.</span></div>
<div class="line">    gid_t <a class="code" href="structreapProcInfo.html#a2f9e09dd2a5857d6e81744d588173928">gid</a>;  <span class="comment">// Group ID.</span></div>
<div class="line">    gid_t <a class="code" href="structreapProcInfo.html#a50542ff9dcd263ded090204e5eb8979d">egid</a>; <span class="comment">// Effective group ID.</span></div>
<div class="line">} <a class="code" href="proc_8h.html#a97c0ef46dadd69950fdb78ae7651aa9f">reapProcInfo</a>;</div>
<div class="ttc" id="aproc_8h_html_a97c0ef46dadd69950fdb78ae7651aa9f"><div class="ttname"><a href="proc_8h.html#a97c0ef46dadd69950fdb78ae7651aa9f">reapProcInfo</a></div><div class="ttdeci">struct reapProcInfo reapProcInfo</div><div class="ttdoc">Information concerning a running process/thread.</div></div>
<div class="ttc" id="astructreapProcInfo_html_a2e89f5fc693e6427576206f2358d6508"><div class="ttname"><a href="structreapProcInfo.html#a2e89f5fc693e6427576206f2358d6508">reapProcInfo::tid</a></div><div class="ttdeci">pid_t tid</div><div class="ttdef"><b>Definition:</b> proc.h:25</div></div>
<div class="ttc" id="astructreapProcInfo_html_a2f9e09dd2a5857d6e81744d588173928"><div class="ttname"><a href="structreapProcInfo.html#a2f9e09dd2a5857d6e81744d588173928">reapProcInfo::gid</a></div><div class="ttdeci">gid_t gid</div><div class="ttdef"><b>Definition:</b> proc.h:28</div></div>
<div class="ttc" id="astructreapProcInfo_html_a50542ff9dcd263ded090204e5eb8979d"><div class="ttname"><a href="structreapProcInfo.html#a50542ff9dcd263ded090204e5eb8979d">reapProcInfo::egid</a></div><div class="ttdeci">gid_t egid</div><div class="ttdef"><b>Definition:</b> proc.h:29</div></div>
<div class="ttc" id="astructreapProcInfo_html_a645f02562bdb93a66aa0b3143bc4c7d6"><div class="ttname"><a href="structreapProcInfo.html#a645f02562bdb93a66aa0b3143bc4c7d6">reapProcInfo::ppid</a></div><div class="ttdeci">pid_t ppid</div><div class="ttdef"><b>Definition:</b> proc.h:24</div></div>
<div class="ttc" id="astructreapProcInfo_html_a905dda89a6a9c10b35d98b983b60a40c"><div class="ttname"><a href="structreapProcInfo.html#a905dda89a6a9c10b35d98b983b60a40c">reapProcInfo::pid</a></div><div class="ttdeci">pid_t pid</div><div class="ttdef"><b>Definition:</b> proc.h:23</div></div>
<div class="ttc" id="astructreapProcInfo_html_adf2ed5c7d151224decad56d7c7bc9f54"><div class="ttname"><a href="structreapProcInfo.html#adf2ed5c7d151224decad56d7c7bc9f54">reapProcInfo::uid</a></div><div class="ttdeci">uid_t uid</div><div class="ttdef"><b>Definition:</b> proc.h:26</div></div>
<div class="ttc" id="astructreapProcInfo_html_af37c3d463a772a7415930cb64e9b462e"><div class="ttname"><a href="structreapProcInfo.html#af37c3d463a772a7415930cb64e9b462e">reapProcInfo::euid</a></div><div class="ttdeci">uid_t euid</div><div class="ttdef"><b>Definition:</b> proc.h:27</div></div>
</div><!-- fragment --><p><code>reapGetProcInfo</code> returns <code>REAP_RET_OK</code> if successful and an error code otherwise (defined in <a href="include/reap/definitions.h">reap/definitions.h</a>). In addition to the error codes defined in that file, various REAP functions can return negative values. Such values will be equal to <code>-1 * errno</code>.</p>
<p>You can also pass a task ID (i.e., a value returned by the <code>gettid</code> system call) as <code>pid</code>.</p>
<p>If <code>exe_path</code> is not <code>NULL</code> and is of size <code>path_size</code>, then it will be populated with the path to the process' executable.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Error messages</h2>
<p>When an error occurs, you can get a description of the error by</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> *<a class="code" href="definitions_8h.html#add4a8e1a68e37d75111801aaafc571ba">reapGetError</a>(<span class="keywordtype">void</span>);</div>
<div class="ttc" id="adefinitions_8h_html_add4a8e1a68e37d75111801aaafc571ba"><div class="ttname"><a href="definitions_8h.html#add4a8e1a68e37d75111801aaafc571ba">reapGetError</a></div><div class="ttdeci">char * reapGetError(void)</div><div class="ttdoc">Acquires the thread-local buffer holding the last error message.</div></div>
</div><!-- fragment --><p>The referenced buffer (which is unique to each thread) will be of size <code>REAP_ERROR_BUFFER_SIZE</code> (defined in <a href="include/reap/config.h">reap/config.h</a>).</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Process iteration</h2>
<p>A <code>reapProcIterator</code> can be used to iterate over all of the running processes (at least, those for which the user has permission to access).</p>
<p>First, the iterator has to be created:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line"><a class="code" href="iterate__proc_8h.html#a67c5d34d844a387598c1295ae9890dd1">reapProcIterator</a> *iterator;</div>
<div class="line"> </div>
<div class="line">ret = <a class="code" href="iterate__proc_8h.html#acdceee0e4d45e6ce45d9feb18bbcde0e">reapProcIteratorCreate</a>(&amp;iterator);</div>
<div class="line"><span class="keywordflow">if</span> ( ret != <a class="code" href="definitions_8h.html#a9b04daa45072df2902834915d0e0a032a475551280e3dc0c9487a288a8eedd4e9">REAP_RET_OK</a> ) {</div>
<div class="line">    <span class="comment">// handle the error</span></div>
<div class="line">}</div>
<div class="ttc" id="adefinitions_8h_html_a9b04daa45072df2902834915d0e0a032a475551280e3dc0c9487a288a8eedd4e9"><div class="ttname"><a href="definitions_8h.html#a9b04daa45072df2902834915d0e0a032a475551280e3dc0c9487a288a8eedd4e9">REAP_RET_OK</a></div><div class="ttdeci">@ REAP_RET_OK</div><div class="ttdef"><b>Definition:</b> definitions.h:23</div></div>
<div class="ttc" id="aiterate__proc_8h_html_a67c5d34d844a387598c1295ae9890dd1"><div class="ttname"><a href="iterate__proc_8h.html#a67c5d34d844a387598c1295ae9890dd1">reapProcIterator</a></div><div class="ttdeci">struct reapProcIterator reapProcIterator</div><div class="ttdoc">Iterates over the running processes.</div><div class="ttdef"><b>Definition:</b> iterate_proc.h:21</div></div>
<div class="ttc" id="aiterate__proc_8h_html_acdceee0e4d45e6ce45d9feb18bbcde0e"><div class="ttname"><a href="iterate__proc_8h.html#acdceee0e4d45e6ce45d9feb18bbcde0e">reapProcIteratorCreate</a></div><div class="ttdeci">int reapProcIteratorCreate(reapProcIterator **iterator)</div><div class="ttdoc">Creates a process iterator.</div></div>
</div><!-- fragment --><p>After that, we can repeatedly pull results from the iterator with</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="iterate__proc_8h.html#a58120fcbd4af9c0df0d20bb5d4e6e3ef">reapProcIteratorNext</a>(<span class="keyword">const</span> <a class="code" href="iterate__proc_8h.html#a67c5d34d844a387598c1295ae9890dd1">reapProcIterator</a> *iterator, <a class="code" href="structreapProcInfo.html">reapProcInfo</a> *info, <span class="keywordtype">char</span> *exe_path, <span class="keywordtype">size_t</span> path_size);</div>
<div class="ttc" id="aiterate__proc_8h_html_a58120fcbd4af9c0df0d20bb5d4e6e3ef"><div class="ttname"><a href="iterate__proc_8h.html#a58120fcbd4af9c0df0d20bb5d4e6e3ef">reapProcIteratorNext</a></div><div class="ttdeci">int reapProcIteratorNext(const reapProcIterator *iterator, reapProcInfo *info, char *exe_path, size_t path_size)</div><div class="ttdoc">Gets the next result.</div></div>
</div><!-- fragment --><p>where the last three arguments are the same as for <code>reapGetProcInfo</code>.</p>
<p>This function returns <code>REAP_RET_OK</code> when yielding a result, <code>REAP_RET_DONE</code> when the iterator has been exhausted, and an error code otherwise.</p>
<p>The iterator must be destroyed when it is no longer needed:</p>
<div class="fragment"><div class="line"><a class="code" href="iterate__proc_8h.html#ab815de744332a1b813e1b3a83b89c5f9">reapProcIteratorDestroy</a>(iterator);</div>
<div class="ttc" id="aiterate__proc_8h_html_ab815de744332a1b813e1b3a83b89c5f9"><div class="ttname"><a href="iterate__proc_8h.html#ab815de744332a1b813e1b3a83b89c5f9">reapProcIteratorDestroy</a></div><div class="ttdeci">void reapProcIteratorDestroy(reapProcIterator *iterator)</div><div class="ttdoc">Destroys an iterator.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md4"></a>
File descriptor iteration</h2>
<p>A <code>reapFdIterator</code> can be used to iterate over a process' open file descriptors.</p>
<p>First, the iterator has to be created:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line"><a class="code" href="iterate__fd_8h.html#aeaf2b1736214a93d6522b31e7c280eef">reapFdIterator</a> *iterator;</div>
<div class="line"> </div>
<div class="line">ret = <a class="code" href="iterate__fd_8h.html#a92d869e6cb9c6ba473e390112b0e871a">reapFdIteratorCreate</a>(some_pid, &amp;iterator);</div>
<div class="line"><span class="keywordflow">if</span> ( ret != <a class="code" href="definitions_8h.html#a9b04daa45072df2902834915d0e0a032a475551280e3dc0c9487a288a8eedd4e9">REAP_RET_OK</a> ) {</div>
<div class="line">    <span class="comment">// handle the error</span></div>
<div class="line">}</div>
<div class="ttc" id="aiterate__fd_8h_html_a92d869e6cb9c6ba473e390112b0e871a"><div class="ttname"><a href="iterate__fd_8h.html#a92d869e6cb9c6ba473e390112b0e871a">reapFdIteratorCreate</a></div><div class="ttdeci">int reapFdIteratorCreate(pid_t pid, reapFdIterator **iterator)</div><div class="ttdoc">Creates a file descriptor iterator for a process.</div></div>
<div class="ttc" id="aiterate__fd_8h_html_aeaf2b1736214a93d6522b31e7c280eef"><div class="ttname"><a href="iterate__fd_8h.html#aeaf2b1736214a93d6522b31e7c280eef">reapFdIterator</a></div><div class="ttdeci">struct reapFdIterator reapFdIterator</div><div class="ttdoc">Iterates over all open file descriptors of a process.</div><div class="ttdef"><b>Definition:</b> iterate_fd.h:22</div></div>
</div><!-- fragment --><p>After that, we can repeatedly acquire file descriptor information with</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="iterate__fd_8h.html#aebc5d2ed3a4501263a0356ddc1bbc24d">reapFdIteratorNext</a>(<span class="keyword">const</span> <a class="code" href="iterate__fd_8h.html#aeaf2b1736214a93d6522b31e7c280eef">reapFdIterator</a> *iterator, <a class="code" href="structreapFdResult.html">reapFdResult</a> *result, <span class="keywordtype">char</span> *file, <span class="keywordtype">size_t</span> file_size);</div>
<div class="ttc" id="aiterate__fd_8h_html_aebc5d2ed3a4501263a0356ddc1bbc24d"><div class="ttname"><a href="iterate__fd_8h.html#aebc5d2ed3a4501263a0356ddc1bbc24d">reapFdIteratorNext</a></div><div class="ttdeci">int reapFdIteratorNext(reapFdIterator *iterator, reapFdResult *result, char *file, size_t file_size)</div><div class="ttdoc">Gets the next result.</div></div>
<div class="ttc" id="astructreapFdResult_html"><div class="ttname"><a href="structreapFdResult.html">reapFdResult</a></div><div class="ttdoc">Result generated by a reapFdIterator.</div><div class="ttdef"><b>Definition:</b> iterate_fd.h:27</div></div>
</div><!-- fragment --><p>where <code><a class="el" href="structreapFdResult.html" title="Result generated by a reapFdIterator.">reapFdResult</a></code> is defined as</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structreapFdResult.html">reapFdResult</a> {</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code" href="structreapFdResult.html#a752aa0dbc7c407b3dfa646e736d1b595">fd</a>;</div>
<div class="line">    dev_t <a class="code" href="structreapFdResult.html#a4b3a436f8bf4ce0faceed1c50fcedddb">device</a>;</div>
<div class="line">    ino_t <a class="code" href="structreapFdResult.html#acae365ce183493d7cab0f4831850ab01">inode</a>;</div>
<div class="line">    mode_t <a class="code" href="structreapFdResult.html#a0c0ada249f16dec3cdad5e0040f8d3fd">mode</a>;</div>
<div class="line">} <a class="code" href="iterate__fd_8h.html#a7eb885c7590bc51a2d64bb2fbf17a821">reapFdResult</a>;</div>
<div class="ttc" id="aiterate__fd_8h_html_a7eb885c7590bc51a2d64bb2fbf17a821"><div class="ttname"><a href="iterate__fd_8h.html#a7eb885c7590bc51a2d64bb2fbf17a821">reapFdResult</a></div><div class="ttdeci">struct reapFdResult reapFdResult</div><div class="ttdoc">Result generated by a reapFdIterator.</div></div>
<div class="ttc" id="astructreapFdResult_html_a0c0ada249f16dec3cdad5e0040f8d3fd"><div class="ttname"><a href="structreapFdResult.html#a0c0ada249f16dec3cdad5e0040f8d3fd">reapFdResult::mode</a></div><div class="ttdeci">mode_t mode</div><div class="ttdef"><b>Definition:</b> iterate_fd.h:31</div></div>
<div class="ttc" id="astructreapFdResult_html_a4b3a436f8bf4ce0faceed1c50fcedddb"><div class="ttname"><a href="structreapFdResult.html#a4b3a436f8bf4ce0faceed1c50fcedddb">reapFdResult::device</a></div><div class="ttdeci">dev_t device</div><div class="ttdef"><b>Definition:</b> iterate_fd.h:29</div></div>
<div class="ttc" id="astructreapFdResult_html_a752aa0dbc7c407b3dfa646e736d1b595"><div class="ttname"><a href="structreapFdResult.html#a752aa0dbc7c407b3dfa646e736d1b595">reapFdResult::fd</a></div><div class="ttdeci">int fd</div><div class="ttdef"><b>Definition:</b> iterate_fd.h:28</div></div>
<div class="ttc" id="astructreapFdResult_html_acae365ce183493d7cab0f4831850ab01"><div class="ttname"><a href="structreapFdResult.html#acae365ce183493d7cab0f4831850ab01">reapFdResult::inode</a></div><div class="ttdeci">ino_t inode</div><div class="ttdef"><b>Definition:</b> iterate_fd.h:30</div></div>
</div><!-- fragment --><p>This function returns <code>REAP_RET_OK</code> when yielding a result, <code>REAP_RET_DONE</code> when the iterator has been exhausted, and an error code otherwise.</p>
<p>if <code>file</code> is not <code>NULL</code> and is of size <code>file_size</code>, then it will be populated with the name of the underlying file.</p>
<p>The iterator must be destroyed when it is no longer needed:</p>
<div class="fragment"><div class="line"><a class="code" href="iterate__fd_8h.html#a2bac8377545acd226ab98f889e3ff0d7">reapFdIteratorDestroy</a>(iterator);</div>
<div class="ttc" id="aiterate__fd_8h_html_a2bac8377545acd226ab98f889e3ff0d7"><div class="ttname"><a href="iterate__fd_8h.html#a2bac8377545acd226ab98f889e3ff0d7">reapFdIteratorDestroy</a></div><div class="ttdeci">void reapFdIteratorDestroy(reapFdIterator *iterator)</div><div class="ttdoc">Destroys an iterator.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md5"></a>
Memory map iteration</h2>
<p>A <code>reapMapIterator</code> can be used to iterate over a process' mapped memory segments.</p>
<p>First, the iterator has to be created:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line"><a class="code" href="iterate__map_8h.html#af835fe303442432641b5f7bac7dcd0b0">reapMapIterator</a> *iterator;</div>
<div class="line"> </div>
<div class="line">ret = <a class="code" href="iterate__map_8h.html#a66e03a0852bed71038ed8d746d0d9c8e">reapMapIteratorCreate</a>(some_pid, &amp;iterator);</div>
<div class="line"><span class="keywordflow">if</span> ( ret != <a class="code" href="definitions_8h.html#a9b04daa45072df2902834915d0e0a032a475551280e3dc0c9487a288a8eedd4e9">REAP_RET_OK</a> ) {</div>
<div class="line">    <span class="comment">// handle the error</span></div>
<div class="line">}</div>
<div class="ttc" id="aiterate__map_8h_html_a66e03a0852bed71038ed8d746d0d9c8e"><div class="ttname"><a href="iterate__map_8h.html#a66e03a0852bed71038ed8d746d0d9c8e">reapMapIteratorCreate</a></div><div class="ttdeci">int reapMapIteratorCreate(pid_t pid, reapMapIterator **iterator)</div><div class="ttdoc">Creates a map iterator for a process.</div></div>
<div class="ttc" id="aiterate__map_8h_html_af835fe303442432641b5f7bac7dcd0b0"><div class="ttname"><a href="iterate__map_8h.html#af835fe303442432641b5f7bac7dcd0b0">reapMapIterator</a></div><div class="ttdeci">struct reapMapIterator reapMapIterator</div><div class="ttdoc">Iterates over all line in a /proc/&lt;PID&gt;/maps file.</div><div class="ttdef"><b>Definition:</b> iterate_map.h:21</div></div>
</div><!-- fragment --><p>After that, we can repeatedly acquire mapped memory information with</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="iterate__map_8h.html#adf251ee5a419d90831ca95dca53ff740">reapMapIteratorNext</a>(<span class="keyword">const</span> <a class="code" href="iterate__map_8h.html#af835fe303442432641b5f7bac7dcd0b0">reapMapIterator</a> *iterator, <a class="code" href="structreapMapResult.html">reapMapResult</a> *result, <span class="keywordtype">char</span> *name, <span class="keywordtype">size_t</span> name_size);</div>
<div class="ttc" id="aiterate__map_8h_html_adf251ee5a419d90831ca95dca53ff740"><div class="ttname"><a href="iterate__map_8h.html#adf251ee5a419d90831ca95dca53ff740">reapMapIteratorNext</a></div><div class="ttdeci">int reapMapIteratorNext(const reapMapIterator *iterator, reapMapResult *result, char *name, size_t name_size)</div><div class="ttdoc">Gets the next result.</div></div>
<div class="ttc" id="astructreapMapResult_html"><div class="ttname"><a href="structreapMapResult.html">reapMapResult</a></div><div class="ttdoc">Result generated by a reapMapIterator.</div><div class="ttdef"><b>Definition:</b> iterate_map.h:26</div></div>
</div><!-- fragment --><p>where <code><a class="el" href="structreapMapResult.html" title="Result generated by a reapMapIterator.">reapMapResult</a></code> is defined as</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structreapMapResult.html">reapMapResult</a> {</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <a class="code" href="structreapMapResult.html#aeee70e3cf8d632282fea11a4ed315d5c">start</a>; <span class="comment">// The start address of the memory segment.</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <a class="code" href="structreapMapResult.html#a28fe901be479bdc89e3a100a37b2c463">end</a>; <span class="comment">// The end address of the memory segment.</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <a class="code" href="structreapMapResult.html#a9bc176f99c6023d63e47ac40b7d3caca">offset</a>; <span class="comment">// The offset of the memory segment within the referent file (if any).</span></div>
<div class="line">    <span class="keywordtype">int</span> <a class="code" href="structreapMapResult.html#a991c7182258828898d11b1ab3d77b29a">permissions</a>; <span class="comment">// The permissions of the memory segment.</span></div>
<div class="line">    dev_t <a class="code" href="structreapMapResult.html#a80e1785a581d520b255fb7cb94c85846">device</a>; <span class="comment">// The device number of the referent file (if any).</span></div>
<div class="line">    ino_t <a class="code" href="structreapMapResult.html#a639825d0b561eb98d57895c551a9616f">inode</a>; <span class="comment">// The inode number of the referent file (if any).</span></div>
<div class="line">} <a class="code" href="iterate__map_8h.html#ad7e7ab708d75a0c4d121b586689f2aea">reapMapResult</a>;</div>
<div class="ttc" id="aiterate__map_8h_html_ad7e7ab708d75a0c4d121b586689f2aea"><div class="ttname"><a href="iterate__map_8h.html#ad7e7ab708d75a0c4d121b586689f2aea">reapMapResult</a></div><div class="ttdeci">struct reapMapResult reapMapResult</div><div class="ttdoc">Result generated by a reapMapIterator.</div></div>
<div class="ttc" id="astructreapMapResult_html_a28fe901be479bdc89e3a100a37b2c463"><div class="ttname"><a href="structreapMapResult.html#a28fe901be479bdc89e3a100a37b2c463">reapMapResult::end</a></div><div class="ttdeci">unsigned long long end</div><div class="ttdef"><b>Definition:</b> iterate_map.h:28</div></div>
<div class="ttc" id="astructreapMapResult_html_a639825d0b561eb98d57895c551a9616f"><div class="ttname"><a href="structreapMapResult.html#a639825d0b561eb98d57895c551a9616f">reapMapResult::inode</a></div><div class="ttdeci">ino_t inode</div><div class="ttdef"><b>Definition:</b> iterate_map.h:32</div></div>
<div class="ttc" id="astructreapMapResult_html_a80e1785a581d520b255fb7cb94c85846"><div class="ttname"><a href="structreapMapResult.html#a80e1785a581d520b255fb7cb94c85846">reapMapResult::device</a></div><div class="ttdeci">dev_t device</div><div class="ttdef"><b>Definition:</b> iterate_map.h:31</div></div>
<div class="ttc" id="astructreapMapResult_html_a991c7182258828898d11b1ab3d77b29a"><div class="ttname"><a href="structreapMapResult.html#a991c7182258828898d11b1ab3d77b29a">reapMapResult::permissions</a></div><div class="ttdeci">int permissions</div><div class="ttdef"><b>Definition:</b> iterate_map.h:30</div></div>
<div class="ttc" id="astructreapMapResult_html_a9bc176f99c6023d63e47ac40b7d3caca"><div class="ttname"><a href="structreapMapResult.html#a9bc176f99c6023d63e47ac40b7d3caca">reapMapResult::offset</a></div><div class="ttdeci">unsigned long long offset</div><div class="ttdef"><b>Definition:</b> iterate_map.h:29</div></div>
<div class="ttc" id="astructreapMapResult_html_aeee70e3cf8d632282fea11a4ed315d5c"><div class="ttname"><a href="structreapMapResult.html#aeee70e3cf8d632282fea11a4ed315d5c">reapMapResult::start</a></div><div class="ttdeci">unsigned long long start</div><div class="ttdef"><b>Definition:</b> iterate_map.h:27</div></div>
</div><!-- fragment --><p>The permissions are some bitwise-OR combination of <code>PROT_READ</code>, <code>PROT_WRITE</code>, and <code>PROT_EXEC</code> from sys/mman.h.</p>
<p>This function returns <code>REAP_RET_OK</code> when yielding a result, <code>REAP_RET_DONE</code> when the iterator has been exhausted, and an error code otherwise.</p>
<p>If <code>name</code> is not <code>NULL</code> and is of size <code>name_size</code>, then it will be populated with the name of the memory segment.</p>
<p>The iterator must be destroyed when it is no longer needed:</p>
<div class="fragment"><div class="line"><a class="code" href="iterate__map_8h.html#a091b60c47699c9025ee1cf9be2a45107">reapMapIteratorDestroy</a>(iterator);</div>
<div class="ttc" id="aiterate__map_8h_html_a091b60c47699c9025ee1cf9be2a45107"><div class="ttname"><a href="iterate__map_8h.html#a091b60c47699c9025ee1cf9be2a45107">reapMapIteratorDestroy</a></div><div class="ttdeci">void reapMapIteratorDestroy(reapMapIterator *iterator)</div><div class="ttdoc">Destroys an iterator.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md6"></a>
Thread iteration</h2>
<p>A <code>reapThreadIterator</code> can be used to iterate over a process' threads.</p>
<p>First, the iterator has to be created:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line"><a class="code" href="iterate__thread_8h.html#a1c90b42905cb57a9e17b33420d041a2e">reapThreadIterator</a> *iterator;</div>
<div class="line"> </div>
<div class="line">ret = <a class="code" href="iterate__thread_8h.html#a2a21032b036f4061ae27d143d299c0c5">reapThreadIteratorCreate</a>(some_pid, &amp;iterator);</div>
<div class="line"><span class="keywordflow">if</span> ( ret != <a class="code" href="definitions_8h.html#a9b04daa45072df2902834915d0e0a032a475551280e3dc0c9487a288a8eedd4e9">REAP_RET_OK</a> ) {</div>
<div class="line">    <span class="comment">// handle the error</span></div>
<div class="line">}</div>
<div class="ttc" id="aiterate__thread_8h_html_a1c90b42905cb57a9e17b33420d041a2e"><div class="ttname"><a href="iterate__thread_8h.html#a1c90b42905cb57a9e17b33420d041a2e">reapThreadIterator</a></div><div class="ttdeci">struct reapThreadIterator reapThreadIterator</div><div class="ttdoc">Iterates over the threads of a process.</div><div class="ttdef"><b>Definition:</b> iterate_thread.h:19</div></div>
<div class="ttc" id="aiterate__thread_8h_html_a2a21032b036f4061ae27d143d299c0c5"><div class="ttname"><a href="iterate__thread_8h.html#a2a21032b036f4061ae27d143d299c0c5">reapThreadIteratorCreate</a></div><div class="ttdeci">int reapThreadIteratorCreate(pid_t pid, reapThreadIterator **iterator)</div><div class="ttdoc">Creates a thread iterator.</div></div>
</div><!-- fragment --><p>After initialization, we can repeatedly acquire thread IDs with</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="iterate__thread_8h.html#a2e47a472c5d035cda27f583f564826fe">reapThreadIteratorNext</a>(<span class="keyword">const</span> <a class="code" href="iterate__thread_8h.html#a1c90b42905cb57a9e17b33420d041a2e">reapThreadIterator</a> *iterator, pid_t *thread);</div>
<div class="ttc" id="aiterate__thread_8h_html_a2e47a472c5d035cda27f583f564826fe"><div class="ttname"><a href="iterate__thread_8h.html#a2e47a472c5d035cda27f583f564826fe">reapThreadIteratorNext</a></div><div class="ttdeci">int reapThreadIteratorNext(const reapThreadIterator *iterator, pid_t *thread)</div><div class="ttdoc">Gets the next result.</div></div>
</div><!-- fragment --><p>This function returns <code>REAP_RET_OK</code> when yielding a result, <code>REAP_RET_DONE</code> when the iterator has been exhausted, and an error code otherwise.</p>
<p>The iterator must be destroyed when it is no longer needed:</p>
<div class="fragment"><div class="line"><a class="code" href="iterate__thread_8h.html#a305828ea9ae7f7c470d59d8741a7ddcd">reapThreadIteratorDestroy</a>(iterator);</div>
<div class="ttc" id="aiterate__thread_8h_html_a305828ea9ae7f7c470d59d8741a7ddcd"><div class="ttname"><a href="iterate__thread_8h.html#a305828ea9ae7f7c470d59d8741a7ddcd">reapThreadIteratorDestroy</a></div><div class="ttdeci">void reapThreadIteratorDestroy(reapThreadIterator *iterator)</div><div class="ttdoc">Destroys an iterator.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md7"></a>
Socket iteration</h2>
<p>A <code>reapNetIterator</code> can be used to iterate over the open sockets in the network namespace.</p>
<p>First, the iterator has to be created:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line"><a class="code" href="iterate__net_8h.html#ac5dda5b184c38418b07b235a1fb3c29f">reapNetIterator</a> *iterator;</div>
<div class="line"> </div>
<div class="line">ret = <a class="code" href="iterate__net_8h.html#a2920fd4e8c8cb37a21a2dabc3158750f">reapNetIteratorCreate</a>(0, &amp;iterator);</div>
<div class="line"><span class="keywordflow">if</span> ( ret != <a class="code" href="definitions_8h.html#a9b04daa45072df2902834915d0e0a032a475551280e3dc0c9487a288a8eedd4e9">REAP_RET_OK</a> ) {</div>
<div class="line">    <span class="comment">// handle the error</span></div>
<div class="line">}</div>
<div class="ttc" id="aiterate__net_8h_html_a2920fd4e8c8cb37a21a2dabc3158750f"><div class="ttname"><a href="iterate__net_8h.html#a2920fd4e8c8cb37a21a2dabc3158750f">reapNetIteratorCreate</a></div><div class="ttdeci">int reapNetIteratorCreate(unsigned int flags, reapNetIterator **iterator)</div><div class="ttdoc">Creates a socket iterator.</div></div>
<div class="ttc" id="aiterate__net_8h_html_ac5dda5b184c38418b07b235a1fb3c29f"><div class="ttname"><a href="iterate__net_8h.html#ac5dda5b184c38418b07b235a1fb3c29f">reapNetIterator</a></div><div class="ttdeci">struct reapNetIterator reapNetIterator</div><div class="ttdoc">Iterates over all open sockets in the network namespace.</div><div class="ttdef"><b>Definition:</b> iterate_net.h:45</div></div>
</div><!-- fragment --><p>The first parameter to the function holds zero or more flags combined with bitwise-OR. The available flags are</p>
<ul>
<li><code>REAP_NET_FLAG_UDP</code>: Find UDP sockets.</li>
<li><code>REAP_NET_FLAG_IPV6</code>: Find IPv6 sockets.</li>
<li><code>REAP_NET_FLAG_DOMAIN</code>: Find Unix domain sockets. If this flag is specified, then all other flags are ignored.</li>
</ul>
<p>By default, the iterator will find TCP sockets over IPv4.</p>
<p>After initialization, we can repeatedly acquire socket information with</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="iterate__net_8h.html#ac78ea5609d32b9c3e7e166ab995dbe6d">reapNetIteratorNext</a>(<span class="keyword">const</span> <a class="code" href="iterate__net_8h.html#ac5dda5b184c38418b07b235a1fb3c29f">reapNetIterator</a> *iterator, <a class="code" href="structreapNetResult.html">reapNetResult</a> *result);</div>
<div class="ttc" id="aiterate__net_8h_html_ac78ea5609d32b9c3e7e166ab995dbe6d"><div class="ttname"><a href="iterate__net_8h.html#ac78ea5609d32b9c3e7e166ab995dbe6d">reapNetIteratorNext</a></div><div class="ttdeci">int reapNetIteratorNext(const reapNetIterator *iterator, reapNetResult *result)</div><div class="ttdoc">Gets the next result.</div></div>
<div class="ttc" id="astructreapNetResult_html"><div class="ttname"><a href="structreapNetResult.html">reapNetResult</a></div><div class="ttdoc">Result generated by a reapNetIterator.</div><div class="ttdef"><b>Definition:</b> iterate_net.h:58</div></div>
</div><!-- fragment --><p>where <code><a class="el" href="structreapNetResult.html" title="Result generated by a reapNetIterator.">reapNetResult</a></code> is defined as</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structreapNetResult.html">reapNetResult</a> {</div>
<div class="line">    <span class="keyword">union </span>{</div>
<div class="line">        <span class="keyword">struct </span>{ <span class="comment">// For IP sockets.</span></div>
<div class="line">            <a class="code" href="structreapNetPeer.html">reapNetPeer</a> <a class="code" href="structreapNetResult.html#ae0d5f377b31f332b549a04638002cb83">local</a>;</div>
<div class="line">            <a class="code" href="structreapNetPeer.html">reapNetPeer</a> <a class="code" href="structreapNetResult.html#a5f1023268d192b9f092963d11f52d403">remote</a>;</div>
<div class="line">        };</div>
<div class="line">        <span class="keyword">struct </span>{ <span class="comment">// For Unix domain sockets.</span></div>
<div class="line">            <span class="keywordtype">char</span> <a class="code" href="structreapNetResult.html#ac04cad82528da5baa8beb56721fe1af8">path</a>[108]; <span class="comment">// Actually, the size is the same as that of the sun_path field of struct sockaddr_un.</span></div>
<div class="line">            <span class="keywordtype">int</span> <a class="code" href="structreapNetResult.html#a2ff01eba477958cc8c2c91d6bc295738">socket_type</a>; <span class="comment">// E.g., SOCK_STREAM, SOCK_DGRAM, SOCK_SEQPACKET.</span></div>
<div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structreapNetResult.html#a97aee606c812cf991168f604c8c1ac34">connected</a> : 1;</div>
<div class="line">        };</div>
<div class="line">    };</div>
<div class="line">    ino_t <a class="code" href="structreapNetResult.html#a645568d368265603401e087cb7b1c9fc">inode</a>; <span class="comment">// The inode number of the socket.</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structreapNetResult.html#a54d6ec1deab547cc709da57962353271">flags</a>; <span class="comment">// The flags that were passed to reapNetIteratorCreate.</span></div>
<div class="line">} <a class="code" href="iterate__net_8h.html#a5b5f85aa73b044c41d455fc7d9c3e22f">reapNetResult</a>;</div>
<div class="ttc" id="aiterate__net_8h_html_a5b5f85aa73b044c41d455fc7d9c3e22f"><div class="ttname"><a href="iterate__net_8h.html#a5b5f85aa73b044c41d455fc7d9c3e22f">reapNetResult</a></div><div class="ttdeci">struct reapNetResult reapNetResult</div><div class="ttdoc">Result generated by a reapNetIterator.</div></div>
<div class="ttc" id="astructreapNetPeer_html"><div class="ttname"><a href="structreapNetPeer.html">reapNetPeer</a></div><div class="ttdoc">Identity of a peer for a TCP/UDP socket.</div><div class="ttdef"><b>Definition:</b> iterate_net.h:50</div></div>
<div class="ttc" id="astructreapNetResult_html_a2ff01eba477958cc8c2c91d6bc295738"><div class="ttname"><a href="structreapNetResult.html#a2ff01eba477958cc8c2c91d6bc295738">reapNetResult::socket_type</a></div><div class="ttdeci">int socket_type</div><div class="ttdef"><b>Definition:</b> iterate_net.h:66</div></div>
<div class="ttc" id="astructreapNetResult_html_a54d6ec1deab547cc709da57962353271"><div class="ttname"><a href="structreapNetResult.html#a54d6ec1deab547cc709da57962353271">reapNetResult::flags</a></div><div class="ttdeci">unsigned int flags</div><div class="ttdef"><b>Definition:</b> iterate_net.h:72</div></div>
<div class="ttc" id="astructreapNetResult_html_a5f1023268d192b9f092963d11f52d403"><div class="ttname"><a href="structreapNetResult.html#a5f1023268d192b9f092963d11f52d403">reapNetResult::remote</a></div><div class="ttdeci">reapNetPeer remote</div><div class="ttdef"><b>Definition:</b> iterate_net.h:62</div></div>
<div class="ttc" id="astructreapNetResult_html_a645568d368265603401e087cb7b1c9fc"><div class="ttname"><a href="structreapNetResult.html#a645568d368265603401e087cb7b1c9fc">reapNetResult::inode</a></div><div class="ttdeci">ino_t inode</div><div class="ttdef"><b>Definition:</b> iterate_net.h:71</div></div>
<div class="ttc" id="astructreapNetResult_html_a97aee606c812cf991168f604c8c1ac34"><div class="ttname"><a href="structreapNetResult.html#a97aee606c812cf991168f604c8c1ac34">reapNetResult::connected</a></div><div class="ttdeci">unsigned int connected</div><div class="ttdef"><b>Definition:</b> iterate_net.h:68</div></div>
<div class="ttc" id="astructreapNetResult_html_ac04cad82528da5baa8beb56721fe1af8"><div class="ttname"><a href="structreapNetResult.html#ac04cad82528da5baa8beb56721fe1af8">reapNetResult::path</a></div><div class="ttdeci">char path[STRUCT_FIELD_SIZE(struct sockaddr_un, sun_path)]</div><div class="ttdef"><b>Definition:</b> iterate_net.h:65</div></div>
<div class="ttc" id="astructreapNetResult_html_ae0d5f377b31f332b549a04638002cb83"><div class="ttname"><a href="structreapNetResult.html#ae0d5f377b31f332b549a04638002cb83">reapNetResult::local</a></div><div class="ttdeci">reapNetPeer local</div><div class="ttdef"><b>Definition:</b> iterate_net.h:61</div></div>
</div><!-- fragment --><p>where <code><a class="el" href="structreapNetPeer.html" title="Identity of a peer for a TCP/UDP socket.">reapNetPeer</a></code> is defined as</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structreapNetPeer.html">reapNetPeer</a> {</div>
<div class="line">    uint16_t <a class="code" href="structreapNetPeer.html#aa203ba643b06f3028b82a9e53c33b175">port</a>;</div>
<div class="line">    uint8_t <a class="code" href="structreapNetPeer.html#ac3e111c66896d4ffd62b07f7830e9869">address</a>[16];</div>
<div class="line">} <a class="code" href="iterate__net_8h.html#adbacf99b131a55cccc682cf9d99fab34">reapNetPeer</a>;</div>
<div class="ttc" id="aiterate__net_8h_html_adbacf99b131a55cccc682cf9d99fab34"><div class="ttname"><a href="iterate__net_8h.html#adbacf99b131a55cccc682cf9d99fab34">reapNetPeer</a></div><div class="ttdeci">struct reapNetPeer reapNetPeer</div><div class="ttdoc">Identity of a peer for a TCP/UDP socket.</div></div>
<div class="ttc" id="astructreapNetPeer_html_aa203ba643b06f3028b82a9e53c33b175"><div class="ttname"><a href="structreapNetPeer.html#aa203ba643b06f3028b82a9e53c33b175">reapNetPeer::port</a></div><div class="ttdeci">uint16_t port</div><div class="ttdef"><b>Definition:</b> iterate_net.h:51</div></div>
<div class="ttc" id="astructreapNetPeer_html_ac3e111c66896d4ffd62b07f7830e9869"><div class="ttname"><a href="structreapNetPeer.html#ac3e111c66896d4ffd62b07f7830e9869">reapNetPeer::address</a></div><div class="ttdeci">uint8_t address[IPV6_SIZE]</div><div class="ttdef"><b>Definition:</b> iterate_net.h:52</div></div>
</div><!-- fragment --><p>If representing a Unix domain socket which is connected to an abstract socket address (i.e., where the first character of the path is a null byte), then all of the null bytes in the path will be replaced by &lsquo;&rsquo;@'`s.</p>
<p>This function returns <code>REAP_RET_OK</code> when yielding a result, <code>REAP_RET_DONE</code> when the iterator has been exhausted, and an error code otherwise.</p>
<p>The iterator must be destroyed when it is no longer needed:</p>
<div class="fragment"><div class="line"><a class="code" href="iterate__net_8h.html#a12d2a2cb470fc2d898c78b9a115821f6">reapNetIteratorDestroy</a>(iterator);</div>
<div class="ttc" id="aiterate__net_8h_html_a12d2a2cb470fc2d898c78b9a115821f6"><div class="ttname"><a href="iterate__net_8h.html#a12d2a2cb470fc2d898c78b9a115821f6">reapNetIteratorDestroy</a></div><div class="ttdeci">void reapNetIteratorDestroy(reapNetIterator *iterator)</div><div class="ttdoc">Destroys an iterator.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md8"></a>
Building REAP</h1>
<p>Shared and static libraries are built using make. Adding <code>debug=yes</code> to the make invocation will disable optimization and build the libraries with debugging symbols.</p>
<p>You can also include REAP in a larger project by including make.mk. Before doing so, however, the <code>REAP_DIR</code> variable must be set to the location of the REAP directory. You can also tell make where to place the shared and static libraries by defining the <code>REAP_LIB_DIR</code> variable (defaults to <code></code>). Similarly, you can define the <code>REAP_OBJ_DIR</code> variable which tells make where to place the object files (defaults to <code>/src</code>).</p>
<p>make.mk adds a target to the <code>CLEAN_TARGETS</code> variable. This is so that implementing</p>
<div class="fragment"><div class="line">clean: $(CLEAN_TARGETS)</div>
<div class="line">    ...</div>
</div><!-- fragment --><p>in your project's Makefile will cause REAP to be cleaned up as well.</p>
<p>The <code>CLEAN_TARGETS</code> variable should be added to <code>.PHONY</code> if you're using GNU make.</p>
<p>make.mk defines the variables <code>REAP_SHARED_LIBRARY</code> and <code>REAP_STATIC_LIBRARY</code> which contain the paths of the specified libraries.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Feature flags</h2>
<p>By defining various preprocessor variables, you can disable some of REAP's features at compile time. The available options are</p>
<ul>
<li><code>REAP_NO_PROC</code> (sets <code>REAP_NO_ITERATE_PROC</code> as well)</li>
<li><code>REAP_NO_ITERATE_PROC</code></li>
<li><code>REAP_NO_ITERATE_FD</code></li>
<li><code>REAP_NO_ITERATE_MAP</code></li>
<li><code>REAP_NO_ITERATE_NET</code></li>
<li><code>REAP_NO_ITERATE_THREAD</code></li>
</ul>
<h1><a class="anchor" id="autotoc_md10"></a>
Testing</h1>
<p>Testing can be performed through the <a href="https://github.com/nickeldan/scrutiny">Scrutiny framework</a>. After installing at least version 0.5.0 of the framework, you can run REAP's tests by</p>
<div class="fragment"><div class="line">make tests</div>
</div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
