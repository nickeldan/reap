/**
 * @file iterate_net.h
 * @author Daniel Walker
 * @brief Exposes namespace-wide socket iteration.
 * @copyright Copyright (c) 2022
 *
 */

#ifndef REAP_ITERATE_NET_H
#define REAP_ITERATE_NET_H

#include <stdint.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/un.h>

#include "definitions.h"

#ifndef REAP_NO_ITERATE_NET

#ifndef IPV4_SIZE
/**
 * @brief The size of an IPv4 address.
 */
#define IPV4_SIZE 4
#endif
#ifndef IPV6_SIZE
/**
 * @brief The size of an IPv6 address.
 */
#define IPV6_SIZE 16
#endif

#ifndef STRUCT_FIELD_SIZE
#define STRUCT_FIELD_SIZE(type, field) sizeof(((type *)0)->field)
#endif

#define REAP_NET_FLAG_UDP    0x01
#define REAP_NET_FLAG_IPV6   0x02
#define REAP_NET_FLAG_DOMAIN 0x04

/**
 * @brief Iterates over all open sockets in the network namespace.
 */
typedef struct reapNetIterator reapNetIterator;

/**
 * @brief Identity of a peer for a TCP/UDP socket.
 */
typedef struct reapNetPeer {
    uint16_t port;              /**< The peer's port.*/
    uint8_t address[IPV6_SIZE]; /**< The peer's address.*/
} reapNetPeer;

/**
 * @brief Result generated by a reapNetIterator.
 */
typedef struct reapNetResult {
    union {
        struct {
            reapNetPeer local;  /**< The local peer.*/
            reapNetPeer remote; /**< The remote peer.*/
        };
        struct {
            char path[STRUCT_FIELD_SIZE(struct sockaddr_un, sun_path)]; /**< The domain socket path.*/
            int socket_type; /**< E.g., SOCK_STREAM, SOCK_DGRAM, SOCK_SEQPACKET.*/
            unsigned int
                connected : 1; /**< Is the socket connected to another?  If not, then it's listening.*/
        };
    };
    ino_t inode;        /**< The inode of the socket.*/
    unsigned int flags; /**< The flags passed to reapNetIteratorInit.*/
} reapNetResult;

/**
 * @brief Creates a socket iterator.
 *
 * @param flags             Flags which determine the IP and transport layers.
 * @param[out] iterator     A pointer to the pointer to be initialized.
 *
 * @return                  REAP_RET_OK if successful and an error code otherwise.
 */
int
reapNetIteratorCreate(unsigned int flags, reapNetIterator **iterator) REAP_EXPORT;

/**
 * @brief Destroys an iterator.
 *
 * @param iterator  A pointer to the iterator.
 */
void
reapNetIteratorDestroy(reapNetIterator *iterator) REAP_EXPORT;

/**
 * @brief Gets the next result.
 *
 * @param iterator      A pointer to the iterator.
 * @param[out] result   A pointer to the result to be populated.
 * @return              REAP_RET_OK if a result was found, REAP_RET_DONE if the iteration is finished, and an
 * error code otherwise.
 */
int
reapNetIteratorNext(const reapNetIterator *iterator, reapNetResult *result) REAP_EXPORT;

#endif  // REAP_NO_ITERATE_NET

#endif  // REAP_ITERATE_NET_H
