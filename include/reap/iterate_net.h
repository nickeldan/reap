/**
 * @file iterate_net.h
 * @author Daniel walker
 * @brief Exposes namespace-wide socket iteration.
 * @copyright Copyright (c) 2022
 *
 */

#ifndef REAP_ITERATE_NET_H
#define REAP_ITERATE_NET_H

#include <stdint.h>
#include <stdio.h>
#include <sys/types.h>

#include "definitions.h"

#ifndef IPV4_SIZE
/**
 * @brief The size of an IPv4 address.
 */
#define IPV4_SIZE 4
#endif
#ifndef IPV6_SIZE
/**
 * @brief The size of an IPv6 address.
 */
#define IPV6_SIZE 16
#endif

/**
 * @brief Iterates over all open sockets in the network namespace.
 *
 * @note User code should not access the iterator's fields.
 */
typedef struct reapNetIterator {
    FILE *file;
    unsigned int udp : 1;
    unsigned int ipv6 : 1;
} reapNetIterator;

/**
 * @brief Identity of a peer for a TCP/UDP socket.
 */
typedef struct reapNetPeer {
    uint16_t port;              /**< The peer's port.*/
    uint8_t address[IPV6_SIZE]; /**< The peer's address.*/
} reapNetPeer;

/**
 * @brief Result generated by a reapNetIterator.
 */
typedef struct reapNetResult {
    reapNetPeer local;     /**< The local peer.*/
    reapNetPeer remote;    /**< The remote peer.*/
    ino_t inode;           /**< The inode of the socket.*/
    unsigned int udp : 1;  /**< Is this a UDP socket?*/
    unsigned int ipv6 : 1; /**< Is this socket over IPv6?*/
} reapNetResult;

#define REAP_NET_FLAG_UDP  0x01
#define REAP_NET_FLAG_IPV6 0x02

/**
 * @brief Initializes an iterator.
 *
 * @param iterator  A pointer to the iterator.
 * @param flags     Flags which determine the IP and transport layers.
 *
 * @return          REAP_RET_OK if successful and an error code otherwise.
 */
int
reapNetIteratorInit(reapNetIterator *iterator, unsigned int flags);

/**
 * @brief Closes an iterator.
 *
 * @param iterator  A pointer to the iterator.
 */
void
reapNetIteratorClose(reapNetIterator *iterator);

/**
 * @brief Gets the next result.
 *
 * @param iterator      A pointer to the iterator.
 * @param[out] result   A pointer to the result to be populated.
 * @return              REAP_RET_OK if a result was found, REAP_RET_DONE if the iteration is finished, and an
 * error code otherwise.
 */
int
reapNetIteratorNext(const reapNetIterator *iterator, reapNetResult *result);

#endif  // REAP_ITERATE_NET_H
